\documentclass[fr]{../../../eplexercises}

\usepackage{../../../eplcode}
\usepackage{../../../eplunits}
\lstset{language=Java, basicstyle=\rm\small\ttfamily, tabsize=8}

\hypertitle{Algorithmique et structures de données}{5}{SINF}{1121}
{Gilles Peiffer}
{Pierre Schaus}

% TODO split exos up once solution can display "Solution à l'exercice x.x.x'"

\section{Types abstraits de données, complexité, collections \java{}; piles, files et listes liées}
\subsection{Exercices théoriques première partie}
\begin{enumerate}
	\item Définissez ce qu'est un type abstrait de données
	(\textsc{TAD}\footnote{\emph{Abstract data type} (\textsc{ADT}) en anglais}).
	En \java{}, est-il préférable de décrire un TAD
	par une classe ou une interface?
	Pourquoi?
	\item Comment faire pour implémenter une \emph{pile}
	par une liste simplement chaînée
	où les opérations \lstinline|push| et \lstinline|pop|
	se font en \textbf{fin de liste}?
	Cette solution est-elle efficace? Argumentez.
	\item Quelles sont les implémentations possibles pour une pile?
	En consultant la documentation sur l'\textsc{API} de \java{},
	décrivez l'implémentation d'une pile par la classe
	\lstinline|java.util.Stack|.
	Allez voir le code source
	de l'implémentation \lstinline|java.util.Stack|
	(\texttt{ctrl+B} depuis IntelliJ).

	Pourquoi pensez-vous que les développeurs de \java{}
	ont choisi cette implémentation
	(hint: argumentez au niveau de la mémoire et du garbage collector)?
	\item Comment faire pour implémenter
	le type abstrait de données \lstinline|Pile|
	à l'aide de deux \emph{files}?
	Décrivez en particulier le fonctionnement
	des méthodes \lstinline|push| et \lstinline|pop| dans ce cas.

	À titre d'exemple, précisez l'état de chacune des deux files
	après avoir empilé les entiers \lstinline|1 2 3|
	à partir d’une pile initialement vide.
	Décrivez ce qu’il se passe ensuite
	lorsque l’on effectue l’opération \lstinline|pop|.

	Quelle est la complexité temporelle de ces méthodes
	si l’on suppose
	que chaque opération \lstinline|enqueue| et \lstinline|dequeue|
	s’exécute en temps constant?

	Cette implémentation d’une pile est-elle efficace
	(pour $n$ opérations)
	par rapport aux autres implémentations
	présentées dans le livre de référence?
	\item
	\begin{itemize}
		\item Qu'est-ce qu'un itérateur en \java{}
		(\lstinline|java.util.Iterator|)?
		\item Pourquoi est-ce util de définir une méthode
		\lstinline|iterator()| sur les structures de données?
		\item Que pensez-vous de permettre
		la modification d'une structure de données
		alors qu'on est en train d'itérer sur celle-ci?
	\end{itemize}

	Pour vous aider dans la réflexion,
	nous vous invitons à lire la spécification de l'\textsc{API} \java{}
	concernant la méthode \lstinline|remove()|.

	Proposez une modification
	du code de l’iterateur de \lstinline|Stack|
	qui lance une erreur de type % had to add text so it breaks the line
	\lstinline|java.util.ConcurrentModificationException|
	si le client modifie la collection
	avec un \lstinline|push()| ou \lstinline|pop()| durant l’itération.
	Est-ce une bonne idée de laisser
	l’implémentation de la méthode \lstinline|remove()| vide
	si on ne désire pas permettre cette fonctionnalité?
	\item La notation $\sim$ (tilde) est utilisée
	dans le livre de référence
	pour l'analyse des temps de calcul des algorithmes.
	En quoi cette notation diffère ou ressemble
	aux notations plus classiquement utilisées
	$\bigoh$ (big Oh), $\bigomega$ (big Omega) et $\bigtheta$ (big Theta)?

	Expliquez précisément les liens et similitudes entre celles-ci.
	Que voyez-vous comme avantage à utiliser la notation $\sim$ (tilde)
	plutôt que $\bigoh$ lorsque c'est possible?
	\item Expliquez comment nous pouvons
	extraire la caractérisation $\sim$ (tilde)
	de l'implémentation d'un algorithme
	à l'aide du test \emph{Doubling ratio}.
	\begin{itemize}
		\item Comment fonctionne ce test?
		\item Quelles sont les limites et avantages de ce test?
	\end{itemize}
	Supposons que nous mesurons les temps d'éxécution $T(n)$ suivants
	(en secondes) d'un programme en fonction de la taille de l'entrée $n$:
	\[
	\begin{array}{cccccccc}
		\hline
		n & 1000 & 2000 & 4000 & 8000 & \num{16000} & \num{32000} & \num{64000} \\
		T(n) & 0 & 0 & 0.1 & 0.3 & 1.3 & 5.1 & 20.5 \\
		\hline
	\end{array}
	\]
	\begin{itemize}
		\item Comment pouvez-vous caractériser au mieux
		l'ordre de croissance de cette fonction?
		\item Que serait le temps d'exécution pour $\num{128000}$?
	\end{itemize}
\end{enumerate}
\begin{solution}
\begin{enumerate}
	\item Un \emph{type abstrait de données}
	est une spécification mathématique d'un ensemble de données
	et de l'ensemble des opérations
	que l'on peut effectuer sur elles.
	Sa représentation interne est inconnue de l'utilisateur.

	Il est préférable de décrire le type abstrait de données
	par une \emph{interface}.
	Une interface en \java{}
	est une liste de signatures de méthodes,
	sans implémentation.
	L'interface specifie le contrat pour le client,
	sans plus.
	De cette façon,
	l'implémentation est séparée,
	dans une toute autre classe.
	Un autre avantage des interfaces est
	que plusieurs représentations
	peuvent coexister dans un même programme.
	Ce n'est pas aussi simple
	lorsque l'\textsc{ADT} est représenté par une simple classe.
	\item Une pile est caractérisée par son comportement \textsc{LIFO}.
	Pour \lstinline|push|,
	il faudrait d'abord itérer à travers la liste
	pour trouver le dernier élément.
	Ensuite, il faudrait
	attacher le nouveau n\oe{}ud derrière la liste
	en mettant une référence vers celui-ci
	dans le champ \lstinline|next| du dernier n\oe{}ud actuel,
	puis mettre le \lstinline|next|
	du nouveau n\oe{}ud à \lstinline|null|.
	En supposant que ces dernières opérations
	se fassent en temps constant,
	cette méthode serait donc en $\bigoh(n)$,
	où $n$ est la taille de la liste,
	car il faut itérer sur tous les n\oe{}uds de la liste.
	Pour \lstinline|pop|,
	on se retrouve dans un cas similaire:
	il faut d'abord itérer jusqu'à l'avant-dernier n\oe{}ud,
	puis récupérer les données du dernier n\oe{}ud,
	et mettre la référence du nouveau dernier à \lstinline|null|.
	On a encore une fois une complexité en $\bigoh(n)$.
	Comme il est possible de faire ces opérations
	en temps constant ($\bigoh(1)$)
	en changeant la représentation interne de la stack,
	ce n'est pas une implémentation efficace.
	\item La pile est implémentée comme
	un \lstinline|Vector| d'un type générique,
	et a donc accès aux fonctions de la classe \lstinline|Vector|.
	La classe \lstinline|Stack|
	n'a que 6 méthodes:
	\lstinline|push()|, \lstinline|pop()|, \lstinline|peek()|,
	\lstinline|empty()|, \lstinline|search()| et un constructeur vide.

	Notamment pour la fonction \lstinline|pop|,
	on utilise une fonction de \lstinline|Vector|,
	\lstinline|removeElementAt()|,
	qui met la référence du n\oe{}ud devenu inutile
	à \lstinline|null|,
	de sorte à ce que le gc\footnote{Garbage collector.}
	puisse récupérer la mémoire.
	\item
	\item
	\item Ces notations sont similaires dans le sens où
	elles représentent la complexité algorithmique asymptotique.
	Cependant, dans le cas de la notation $\sim$
	on inclut un facteur multiplicatif de sorte à ce que
	\[
	g(N) \sim f(n) \textnormal{ signifie } \lim_{N \to \infty} \frac{g(N)}{f(N)} = 1\,.
	\]
	La notation $\sim$ est donc plus précise,
	et c'est pour cela qu'elle peut être préférable à la notation $\bigoh$.
	\item On se base sur la formule suivante:
	\[
	T(N) \sim a N^b \log N \iff T(2N) \sim a (2N)^b \log(2N)
	\]
	et donc
	\[
	\frac{T(2N)}{T(N)} \sim 2^b\,.
	\]
	Ce test n'est pas effectif si
	les ratios consécutifs n'approchent pas une valeur limite,
	mais pour la plupart des programmes,
	ils le font.
	Il a l'avantage d'être facile à effectuer,
	et qu'il fonctionne pour une grosse majorité des algorithmes.

	Pour ce qui en est des temps d'exécution proposés,
	on remarque que
	\[
	\frac{20.5}{5.1} \approx \frac{5.1}{1.3} \approx \frac{1.3}{0.3} \approx 4 \approx 2^b \implies b \approx 2\,.
	\]
	On a donc $T(n) \in \bigoh(n^2)$.
	En multipliant le temps pour $\num{64000}$ par $4$,
	on peut prédire que le temps d'exécution
	sera d'environ $\SI{82}{\second}$ pour $n = \num{128000}$.
\end{enumerate}
\end{solution}

\subsection{Exercices théoriques supplémentaires}
\begin{enumerate}
	\item Que signifient les paramètres \lstinline|-Xmx|, \lstinline|-Xms|
	que l'on peut passer à la \textsc{JVM} pour l'exécution d'un bytecode?
	Est-ce que ces paramètres peuvent influencer
	la vitesse d'exécution d'un programme \java{}? Pourquoi?
	\item \leavevmode
	\begin{itemize}
		\item Qu’est-ce qu’un bon ensemble de tests unitaires
		pour vérifier l’exactitude d’une structure de données?
		\item Pensez-vous aux cas limites?
		\item Pensez-vous à
		la valeur maximale des entiers, doubles, etc.?
		\item En quoi la génération de données aléatoire
		peut être utile pour tester les structures de données?
		\item Pourquoi est-ce important
		de travailler avec une semence (seed) fixée?
		\item En quoi un outil d’analyse de couverture de code
		peut être utile
		(tel que \href{http://eclemma.org/jacoco/}{Jacoco})
		pour vous aidez à concevoir des tests?
		\item Comment vérifier expérimentalement
		que l’implémentation d’une structure de données
		ou un algorithme a bien
		la complexité temporelle théorique attendue?
	\end{itemize}
\end{enumerate}
\begin{solution}
\begin{enumerate}
	\item
\end{enumerate}
\end{solution}

\end{document}
